Require Import Nat.
Require Import ZArith.

(* Exercise 6.1 *)
(* Define an inductive type for seasons and then
  use the function month_rec to define a function
  that maps every month to the season that contains
  most of its days. *)

Inductive month : Set :=
  | January
  | February
  | March
  | April
  | May
  | June
  | July
  | August
  | September
  | October
  | November
  | December.

Inductive season : Set :=
  | Winter
  | Spring
  | Summer
  | Autumn.

Definition month_season_rec :=
  month_rec (fun _ => season)
    Winter Winter Spring
    Spring Spring Summer
    Summer Summer Autumn
    Autumn Autumn Winter.

(* Exercise 6.2 *)
(* What are the types of bool_ind and bool_rec
  that are generated by the Coq system for the type bool? *)

Check bool_ind.
(* forall P : bool -> Prop, P true -> P false -> forall b : bool, P b *)
Check bool_rec.
(* forall P : bool -> Set, P true -> P false -> forall b : bool, P b *)

(* Exercise 6.3 *)
(* Prove in two different ways the following theorem: *)

Definition bool_equal := forall b : bool, b = true \/ b = false.

(* 1. By directly building a proof term with the right type,
  with the help of theorems or_introl, or_intror,
  and refl_equal *)

Definition bool_eq_term : bool_equal :=
  fun b => bool_ind (fun b => b = true \/ b = false)
    (or_introl refl_equal) (or_intror refl_equal) b.

(* 2. By using pattern, apply, left, right, and reflexivity.*)

Definition bool_eq_proof : bool_equal.
Proof.
  intro.
  pattern b.
  apply bool_ind.
  - apply or_introl. reflexivity.
  - apply or_intror. reflexivity.
Qed.

(* Exercise 6.4 *)
(* Using the type introduced for seasons in Exercise 6.1
  page 139, write the function that maps any month to the season
  that contains most of its days, this time using the pattern
  matching construct. *)

Definition month_season (m : month) : season := 
  match m with
  | December | January | February => Winter
  | March | April | May => Spring
  | June | July | August => Summer
  | September | October | November => Autumn
  end.

(* Exercise 6.5 *)
(* Write the function that maps every month that has an even
  number of days to the boolean value true and the others to false. *)

Definition month_length (leap : bool) (m : month) : nat :=
  match m with
  | February => if leap then 29 else 28
  | April | June | September | November => 30
  | _ => 31
  end.

Definition even_days (leap : bool) : month -> bool :=
  fun m : month => even (month_length leap m).

(* Exercise 6.6 *)
(* Define the functions bool_xor, bool_and, bool_or, bool_eq
  of type bool -> bool -> bool, and the function bool_not of
  type bool -> bool. Prove the following theorems: *)

Definition bool_xor (a b : bool) := 
  match a, b with
  | true, true | false, false => false
  | _, _ => true
  end.

Definition bool_and (a b : bool) :=
  match a, b with
  | true, true => true
  | _, _ => false
  end.

Definition bool_or (a b : bool) :=
  match a, b with
  | false, false => false
  | _, _ => true
  end.

Definition bool_eq (a b : bool) :=
  match a, b with
  | true, true | false, false => true
  | _, _ => false
  end.

Definition bool_not (b : bool) :=
  match b with
  | false => true
  | true => false
  end.

Goal forall b1 b2 : bool, bool_xor b1 b2 = bool_not (bool_eq b1 b2).
Proof. intros; elim b1; elim b2; simpl; reflexivity. Qed.

Goal forall b1 b2 : bool,
  bool_not (bool_and b1 b2) = bool_or (bool_not b1) (bool_not b2).
Proof. intros; elim b1; elim b2; simpl; reflexivity. Qed.

Goal forall b : bool, bool_not (bool_not b) = b.
Proof. apply bool_ind; simpl; reflexivity. Qed.

Goal forall b : bool, bool_or b (bool_not b) = true.
Proof. apply bool_ind; simpl; reflexivity. Qed.

Goal forall b1 b2 : bool, bool_eq b1 b2 = true -> b1 = b2.
Proof.
  intros b1 b2; elim b1; elim b2; simpl;
  try reflexivity;
  intros H; rewrite H; reflexivity.
Qed.

Goal forall b1 b2 : bool, b1 = b2 -> bool_eq b1 b2 = true.
Proof.
  intros b1 b2; elim b1; elim b2; simpl;
  try reflexivity;
  intros H; rewrite H; reflexivity.
Qed.
  
Goal forall b1 b2 : bool,
  bool_not (bool_or b1 b2) = bool_and (bool_not b1) (bool_not b2).
Proof.
  intros b1 b2; elim b1; elim b2; simpl; reflexivity.
Qed.

Goal forall b1 b2 b3 : bool,
  bool_or (bool_and b1 b3) (bool_and b2 b3) = bool_and (bool_or b1 b2) b3.
Proof.
  intros; elim b1; elim b2; elim b3; simpl; reflexivity.
Qed.

(* Exercise 6.7 *)
(* What is the type of plane_rec? *)

Inductive plane : Set := point : Z -> Z -> plane.
Check plane_rec.

(* forall P : plane -> Set, 
    (forall z z0 : Z, P (point z z0)) -> forall p : plane, P p *)

(* Note: There is a discrepancy between the book and output seen here *)

Reset plane.
Record plane : Set := point {abscissa: Z; ordinate: Z}.

(* Note (cont.): 
  In the book, it states that this definition yeilds the same 
  printout as the defintion above:
    Inductive plane : Set := point : Z -> Z -> plane
  
  However, using Coq 8.17, this is not the case.
  As a result, there is no _plane_rec_ generated for
  the Record definition.

  It seems Records have distinguished themselves from their
  behaviourally adjacent inductive types.

  If this is an actual chnage in Coq's implmentation, a
  possible motivation could be the integration of
  typeclasses, which is presumably a fairly new feature.

  Further investigation would involve checking versions
  in between the textbook realease version and 8.17 to 
  discover how record types may have changed.
*)

(* Exercise 6.8 *)
(* Define a function that computes the "Manhattan" distance
  for points of the plane (the Manhattan distance is the sum
  of the absolute values of differences of coordinates *)

Open Scope Z_scope.
Definition manhattan : plane -> plane -> Z :=
  fun p1 p2 => 
    let (x1, y1) := p1 in 
    let (x2, y2) := p2 in
    (Z.abs (x1 - x2)) + (Z.abs (y1 - y2)).

(* Exercise 6.9 *)
(* What is the type of vehicle_rec? Use this function to define
  an equivalent to nb_seats. *)

Inductive vehicle : Set :=
  bicycle : nat -> vehicle | motorized : nat -> nat -> vehicle.

Check vehicle_rec.
(* 
  forall P : vehicle -> Set 
    (forall n : nat, P (bicycle n)) ->
    (forall n n0 : nat, P (motorized n n0)) ->
    forall v : vehicle, P v
*)

Definition nb_seats (v : vehicle) : nat :=
  match v with
  | bicycle x => x
  | motorized x _ => x
  end.

Definition nb_seats' (v : vehicle) : nat :=
  vehicle_rec (fun _ => nat)
    (fun n => n)
    (fun n _ => n) v.

Goal forall v, nb_seats v = nb_seats' v.
Proof.
  unfold nb_seats, nb_seats'.
  intros. elim v; simpl; auto.
Qed.

