Require Import Nat.
Require Import ZArith.
Require Import FunctionalExtensionality.

(* Exercise 6.1 *)
(* Define an inductive type for seasons and then
  use the function month_rec to define a function
  that maps every month to the season that contains
  most of its days. *)

Inductive month : Set :=
  | January
  | February
  | March
  | April
  | May
  | June
  | July
  | August
  | September
  | October
  | November
  | December.

Inductive season : Set :=
  | Winter
  | Spring
  | Summer
  | Autumn.

Definition month_season_rec :=
  month_rec (fun _ => season)
    Winter Winter Spring
    Spring Spring Summer
    Summer Summer Autumn
    Autumn Autumn Winter.

(* Exercise 6.2 *)
(* What are the types of bool_ind and bool_rec
  that are generated by the Coq system for the type bool? *)

Check bool_ind.
(* forall P : bool -> Prop, P true -> P false -> forall b : bool, P b *)
Check bool_rec.
(* forall P : bool -> Set, P true -> P false -> forall b : bool, P b *)

(* Exercise 6.3 *)
(* Prove in two different ways the following theorem: *)

Definition bool_equal := forall b : bool, b = true \/ b = false.

(* 1. By directly building a proof term with the right type,
  with the help of theorems or_introl, or_intror,
  and refl_equal *)

Definition bool_eq_term : bool_equal :=
  fun b => bool_ind (fun b => b = true \/ b = false)
    (or_introl refl_equal) (or_intror refl_equal) b.

(* 2. By using pattern, apply, left, right, and reflexivity.*)

Definition bool_eq_proof : bool_equal.
Proof.
  intro.
  pattern b.
  apply bool_ind.
  - apply or_introl. reflexivity.
  - apply or_intror. reflexivity.
Qed.

(* Exercise 6.4 *)
(* Using the type introduced for seasons in Exercise 6.1
  page 139, write the function that maps any month to the season
  that contains most of its days, this time using the pattern
  matching construct. *)

Definition month_season (m : month) : season := 
  match m with
  | December | January | February => Winter
  | March | April | May => Spring
  | June | July | August => Summer
  | September | October | November => Autumn
  end.

(* Exercise 6.5 *)
(* Write the function that maps every month that has an even
  number of days to the boolean value true and the others to false. *)

Definition month_length (leap : bool) (m : month) : nat :=
  match m with
  | February => if leap then 29 else 28
  | April | June | September | November => 30
  | _ => 31
  end.

Definition even_days (leap : bool) : month -> bool :=
  fun m : month => even (month_length leap m).

(* Exercise 6.6 *)
(* Define the functions bool_xor, bool_and, bool_or, bool_eq
  of type bool -> bool -> bool, and the function bool_not of
  type bool -> bool. Prove the following theorems: *)

Definition bool_xor (a b : bool) := 
  match a, b with
  | true, true | false, false => false
  | _, _ => true
  end.

Definition bool_and (a b : bool) :=
  match a, b with
  | true, true => true
  | _, _ => false
  end.

Definition bool_or (a b : bool) :=
  match a, b with
  | false, false => false
  | _, _ => true
  end.

Definition bool_eq (a b : bool) :=
  match a, b with
  | true, true | false, false => true
  | _, _ => false
  end.

Definition bool_not (b : bool) :=
  match b with
  | false => true
  | true => false
  end.

Goal forall b1 b2 : bool, bool_xor b1 b2 = bool_not (bool_eq b1 b2).
Proof. intros; elim b1; elim b2; simpl; reflexivity. Qed.

Goal forall b1 b2 : bool,
  bool_not (bool_and b1 b2) = bool_or (bool_not b1) (bool_not b2).
Proof. intros; elim b1; elim b2; simpl; reflexivity. Qed.

Goal forall b : bool, bool_not (bool_not b) = b.
Proof. apply bool_ind; simpl; reflexivity. Qed.

Goal forall b : bool, bool_or b (bool_not b) = true.
Proof. apply bool_ind; simpl; reflexivity. Qed.

Goal forall b1 b2 : bool, bool_eq b1 b2 = true -> b1 = b2.
Proof.
  intros b1 b2; elim b1; elim b2; simpl;
  try reflexivity;
  intros H; rewrite H; reflexivity.
Qed.

Goal forall b1 b2 : bool, b1 = b2 -> bool_eq b1 b2 = true.
Proof.
  intros b1 b2; elim b1; elim b2; simpl;
  try reflexivity;
  intros H; rewrite H; reflexivity.
Qed.
  
Goal forall b1 b2 : bool,
  bool_not (bool_or b1 b2) = bool_and (bool_not b1) (bool_not b2).
Proof.
  intros b1 b2; elim b1; elim b2; simpl; reflexivity.
Qed.

Goal forall b1 b2 b3 : bool,
  bool_or (bool_and b1 b3) (bool_and b2 b3) = bool_and (bool_or b1 b2) b3.
Proof.
  intros; elim b1; elim b2; elim b3; simpl; reflexivity.
Qed.

(* Exercise 6.7 *)
(* What is the type of plane_rec? *)

Inductive plane : Set := point : Z -> Z -> plane.
Check plane_rec.

(* forall P : plane -> Set, 
    (forall z z0 : Z, P (point z z0)) -> forall p : plane, P p *)

(* Note: There is a discrepancy between the book and output seen here *)

Reset plane.
Record plane : Set := point {abscissa: Z; ordinate: Z}.

(* Note (cont.): 
  In the book, it states that this definition yeilds the same 
  printout as the defintion above:
    Inductive plane : Set := point : Z -> Z -> plane
  
  However, using Coq 8.17, this is not the case.
  As a result, there is no _plane_rec_ generated for
  the Record definition.

  It seems Records have distinguished themselves from their
  behaviourally adjacent inductive types.

  If this is an actual chnage in Coq's implmentation, a
  possible motivation could be the integration of
  typeclasses, which is presumably a fairly new feature.

  Further investigation would involve checking versions
  in between the textbook realease version and 8.17 to 
  discover how record types may have changed.
*)

(* Exercise 6.8 *)
(* Define a function that computes the "Manhattan" distance
  for points of the plane (the Manhattan distance is the sum
  of the absolute values of differences of coordinates *)

Open Scope Z_scope.
Definition manhattan : plane -> plane -> Z :=
  fun p1 p2 => 
    let (x1, y1) := p1 in 
    let (x2, y2) := p2 in
    (Z.abs (x1 - x2)) + (Z.abs (y1 - y2)).

(* Exercise 6.9 *)
(* What is the type of vehicle_rec? Use this function to define
  an equivalent to nb_seats. *)

Inductive vehicle : Set :=
  bicycle : nat -> vehicle | motorized : nat -> nat -> vehicle.

Check vehicle_rec.
(* 
  forall P : vehicle -> Set 
    (forall n : nat, P (bicycle n)) ->
    (forall n n0 : nat, P (motorized n n0)) ->
    forall v : vehicle, P v
*)

Definition nb_seats (v : vehicle) : nat :=
  match v with
  | bicycle x => x
  | motorized x _ => x
  end.

Definition nb_seats' (v : vehicle) : nat :=
  vehicle_rec (fun _ => nat)
    (fun n => n)
    (fun n _ => n) v.

Goal forall v, nb_seats v = nb_seats' v.
Proof.
  unfold nb_seats, nb_seats'.
  intros. elim v; simpl; auto.
Qed.

(* Exercise 6.10 *)
(* Define a function is_January that maps January
  to True and any other month to False, using the
  function month_rect *)

Definition is_January : month -> Prop :=
  month_rect _
    True False False False False False
    False False False False False False.

(* Exercise 6.11 *)
(* Use the same technique to build a proof of true =/= false. *)

Goal (true <> false).
Proof.
  unfold not; intros H.
  change ((fun b : bool =>
    match b with | true => True | false => False end) false).
  rewrite <- H.
  trivial.
Qed.

(* Exercise 6.12 *)
(* For the vehicle type (see Sect. 6.1.6), use the same
  technique to build a proof that no bicycle is equal to a
  motorized vehicle. *)

Goal forall a b c, (bicycle a) <> (motorized b c).
Proof.
  unfold not; intros a b c H.
  change ((fun v => match v with
    | bicycle _ => True 
    | motorized _ _ => False
    end) (motorized b c)).
  rewrite <- H.
  trivial.
Qed.

(* Exercise 6.13 *)
(* This exercise shows a use of discriminate and underlines
  the danger of adding axioms to the system. The "theory"
  introduced here proposes a description of rational numbers
  as fractions with a non-zero denominator. An axiom is added
  to indicate that two rational numbers are equal as soon as they
  satisfy a classical arithmetic condition. *)

Open Scope nat_scope. 
Require Import Arith.
Record RatPlus : Set :=
  mkRat {top : nat; bottom : nat; bottom_condition : bottom <> O}.

Axiom eq_RatPlus : forall r r' : RatPlus,
  top r * bottom r' = top r' * bottom r -> r = r'.

(* Prove that this theory is inconsistent (just construct a
  proof of False). When this exercise is solved, you should
  remove this construction from the environment, using the command
  Reset eq_RatPlus. *)

Goal False.
Proof.
  assert (H1: 1 <> 0); auto.
  assert (H2: 2 <> 0); auto.
  cut ((mkRat 1 1 H1) = (mkRat 2 2 H2)).
  - discriminate.
  - apply eq_RatPlus; simpl; reflexivity.
Qed.

Reset eq_RatPlus.

(* Exercise 6.14 *)
(* Reproduce the above discussion for the function
  mult: compile a table describing convertibility
  for simple patterns of the two arguments. *)

Fixpoint mult (n m : nat) {struct n} : nat :=
  match n with
  | O   => O
  | S p => (plus m (mult p m))
  end.

(* 
  mult 0 0              => 0
  mult 0 m              => m
  mult (S p) 0          => 0 + (mult p 0)
  mult (S p) m          => m + (mult p m)
  mult (S (S p)) (S m)  => (S m) + (mult (S p) (S m))
*)

(* Exercise 6.15 *)
(* Define a function of type nat->bool that only
  returns true for numbers smaller than 3, in other
  terms "S (S (S 0))." *)

Definition lt3 n :=
  match n with
  | S (S (S n)) => false
  | _ => true
  end.

(* Exercise 6.16 *)
(* Define an addition function so that the principal
  argument is second instead of first argument. *)

Fixpoint plus' (n m : nat) {struct m} : nat :=
  match m with
  | O   => n
  | S p => S (plus' n p)
  end.
    
(* Exercise 6.17 *)
(* Define a function sum_f that takes as arguments
  a number n and a function f of type nat->Z and returns
  the sum of all values of f for the natural numbers that
  are strictly smaller than n. *)

Fixpoint sum_f (n : nat) (f : nat->nat) : nat :=
  match n with
  | O   => O
  | S n => (f n) + (sum_f n f)
  end.

(* Exercise 6.18 *)
(* Define two_power:nat->nat so that "two_power n" is 2^n. *)

Fixpoint two_power (n : nat) : nat :=
  match n with
  | O   => 1
  | S n => 2 * (two_power n)
  end.

(* Exercise 6.19 *)
(* What is the representation in the type _positive_
  for numbers 1000, 25, 512? *)

(* 1000 = 1111101000_b*)
Check xO (xO (xO (xI (xO (xI (xI (xI (xI (xH))))))))).

(* 25 = 11001_b *)
Check xI (xO (xO (xI xH))).

(* 512 = 100000000_b *)
Check xO (xO (xO (xO (xO (xO (xO (xO xH))))))).

(* Exercise 6.20 *)
(* Build the function pos_even_bool of type _positive->bool_
that returns the value true exactly when the argument is even. *)
Definition pos_even_bool (p : positive) : bool :=
  match p with
  | xO _ => true
  | _    => false
  end.

SearchPattern (positive->Z).

(* Exercise 6.21 *)
(* Build the function pos_div4 of type positive->Z that
  maps any number z to the integer part of z/4. *)
Definition pos_div4 (p : positive) : Z :=
  match p with
  | xO (xO p') | xO (xI p')
  | xI (xO p') | xI (xI p') =>  Zpos p' 
  | _ => 0
  end.

(* Exercise 6.22 *)
(* Assuming there exists a function pos_mult that
  describes the multiplication of two positive
  representations and returns a positive representation,
  use this function to build a function that multiplies
  numbers of type Z and returns a value of type Z. *)

Definition Zmult : Z->Z->Z := fun a b =>
  match a, b with
  | Zpos p, Zpos q | Zneg p, Zneg q => Zpos (Pos.mul p q)
  | Zneg p, Zpos q | Zpos p, Zneg q => Zneg (Pos.mul p q)
  | _, _ => 0%Z
  end.

(* Exercise 6.23 *)
(* Build the inductive type that represents the language
  of propositional logic without variables:
    L = L/\L | L\/L | ~L | L => L | L_True | L_False *)

Inductive prop :=
  | L_And : prop->prop->prop
  | L_Or : prop->prop->prop
  | L_Not : prop->prop
  | L_Imp : prop->prop->prop
  | L_True : prop
  | L_False : prop.

(* Exercise 6.24 *)
(* Every strictly positive rational number can be
  obtained in a unique manner by a succession of
  applications of functions N and D on the number one,
  where N and D are defined by the following equations:

    N(x) = 1 + x, D(x) = 1 / (1 + (1 / x)) 
  
  We can associate any strictly positive rational number
  with an element of an inductive type with one constructor
  for one, and two other constructors representing the
  functions N and D. Define this inductive type (see
  the related exercise 6.44).
*)

Inductive rational :=
  | rI : rational
  | rN : rational->rational
  | rD : rational->rational.

(* Exercise 6.25 *)
(* The Coq library ZArith provides a function
    Zeq_bool : Z -> Z -> bool
  to compare two integer values and return a boolean
  value expressing the result. Using this function define
  a function value_present with the type
    value_present : Z -> Z_btree -> bool
  that determines whether an integer appears
  in a binary tree. *)

Inductive Z_btree : Set :=
  Z_bleaf : Z_btree | Z_bnode : Z->Z_btree->Z_btree->Z_btree.

Fixpoint value_present (z : Z) (t : Z_btree) : bool :=
  match t with
  | Z_bleaf => false
  | Z_bnode x l r => (Zeq_bool x z) || value_present z l || value_present z r
  end.

(* Exercise 6.26 *)
(* Define a function power: Z->nat->Z to compute the power
  of an integer and a function discrete_log:
  positive->nat that maps any number p
  to the number n such that 2^n =< p < 2^(n+1). *)

Fixpoint discrete_log (p : positive) : nat :=
  match p with
  | xH => 0
  | xO p' | xI p' => 1 + discrete_log p'
  end.

(* Exercise 6.27 *)
(* Define a function zero_present: Z_fbtree->bool that 
  maps any tree x to true if and only ifa contains the
  value zero. *)

Inductive Z_fbtree : Set :=
 | Z_fleaf : Z_fbtree
 | Z_fnode : Z -> (bool->Z_fbtree) -> Z_fbtree.

Fixpoint zero_present (t : Z_fbtree) : bool :=
  match t with
  | Z_fleaf => false
  | Z_fnode x f => (Z.eqb x 0)
    || zero_present (f true) || zero_present (f false)
  end.

(* Exercise 6.28 *)
(* Define a function that checks whether the zero value
  occurs in an infinitely branching tree at a node 
  reachable only by indices smaller than a number n. *)

Inductive Z_inf_branch_tree: Set :=
  | Z_inf_leaf : Z_inf_branch_tree
  | Z_inf_node : Z -> (nat->Z_inf_branch_tree) -> Z_inf_branch_tree.

Fixpoint or_f (n : nat) (f : nat -> bool) : bool :=
  match n with
  | O => false
  | S n' => f n' || or_f n' f
  end. 

Fixpoint zero_present_inf (n : nat) (t : Z_inf_branch_tree) : bool :=
  match t with
  | Z_inf_leaf => false
  | Z_inf_node x f => (Z.eqb x 0) 
    || or_f n (fun i => zero_present_inf n (f i)) 
  end.

(* Exercise 6.29 *)
(* Redo the proof of theorem plus_n_0, using only the tactics
  intro, assumption, elim, simpl, apply, and reflexivity. *)

Goal forall n:nat, n = n + 0.
Proof.
  intro.
  elim n.
  - reflexivity.
  - intro m; intro H.
    simpl. rewrite <- H; reflexivity.
Qed.

(* Exercise 6.30 *)
(* This exercise uses the types Z_btree and Z_fbtree
  introduced in Sects. 6.3.4 and 6.3.5.1. Define functions
    f1: Z_btree -> Z_fbtree and f2: Z_fbtree -> Z_btree
  that establish the most natural bijection between the
  two types (see Sects. 6.3.4 and 6.3.5.1). Prove the 
  following lemma:
    forall t:Z_btree, f2 (f1 t) = t.
  What is missing to prove the following statement?
    forall t:Z_fbtree, f1 (f2 t) = t. 
*)

Print Z_btree.

Fixpoint f1 (t : Z_btree) : Z_fbtree :=
  match t with
  | Z_bleaf => Z_fleaf
  | Z_bnode x l r => Z_fnode x (fun b => if b then f1 l else f1 r)
  end.

Fixpoint f2 (t : Z_fbtree) : Z_btree :=
  match t with
  | Z_fleaf => Z_bleaf
  | Z_fnode x f => Z_bnode x (f2 (f true)) (f2 (f false))
  end.

Goal forall t:Z_btree, f2 (f1 t) = t.
Proof.
  intros.
  elim t; simpl.
  - reflexivity.
  - intros x l IHl r IHr.
    rewrite IHl, IHr.
    reflexivity.
Qed.

(* Second proof requires functional extensionality *)

Theorem f_equal : forall (A B : Type) (f: A -> B) (x y: A),
  x = y -> f x = f y.
Proof. intros A B f x y eq. rewrite eq. reflexivity. Qed.

Goal forall t:Z_fbtree, f1 (f2 t) = t.
Proof.
  intros.
  elim t; simpl.
  - reflexivity.
  - intros x f H.
    apply f_equal.
    extensionality b.
    elim b; apply H.
Qed.

(* Exercise 6.31 *)
(* Prove forall n : nat, (mult2 n) = n+n (see Sect. 6.3.3) *)

Fixpoint mult2 (n:nat) : nat :=
  match n with
  | O => O
  | S p => S (S (mult2 p))
  end.

Goal forall n : nat, (mult2 n) = n+n.
Proof.
  intros.
  elim n; simpl.
  - reflexivity.
  - intros; rewrite H.
    f_equal.
    apply plus_n_Sm.
Qed.

(* Exercise 6.32 *)
(* The sum of the first n natural numbers is defined
  with the following function: *)

Fixpoint sum_n (n:nat) : nat :=
  match n with
  | O => O
  | S p => S p + sum_n p
  end.

(* Prove the following statement: *)
Goal forall n:nat, 2 * sum_n n = n*n + n.
Proof.
  intros.
  elim n; simpl.
  - reflexivity.
  - intros m H.
    rewrite <- plus_n_O in *.
    repeat rewrite <- plus_n_Sm.
    f_equal. f_equal. 
    rewrite Nat.mul_succ_r.
    rewrite <- H.
    rewrite Nat.add_assoc, Nat.add_comm.
    repeat rewrite Nat.add_assoc.
    f_equal. f_equal.
    apply Nat.add_comm.
Qed.

(* Exercise 6.33 *)
(* Prove the following statement: *)
Goal forall n:nat, n <= sum_n n.
Proof.
  intros. elim n; simpl.
  - reflexivity.
  - intros m H.
    apply le_n_S.
    apply Nat.le_add_r.
Qed.