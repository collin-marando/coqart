---- Tacticals ----
* Generalized compostion
  t1; t2; [t3 | t4 [t5 t6]]
  ; = compostion
  | = disjunction
  _ = conjunction

* or_else
  t1 || t2 || t3
  attempt t1, if fail, attempt t2, if fail... else fail
  Note : try t1 = t1 || idtac

* try (attempt or_else no-op)
  try t1 = t1 || idtac

* try solve (solve or_else no-op)
  try solve t1 = try (t1; fail)

* repeat (repeat and stop on fail)

---- Tactics ----

* intros (primitive typing rule, Lam)
  move implication premises from the goal to the context

* apply (primitive typing rule, App)
  _implication elimination_ using modus ponens, chaining
  the rule to generate multiple goals for each of the
  head types of the implication chain.

* exact (direct proof)
  solve the goal by providing a valid proof term

* assumption (proof using context)
  solve the goal using an existing context variable

* idtac (no-op)
  do nothing; useful as neutral op for multi-tacs

* fail
  fail proof; useful as ternimal op for multi-tacs

* cut [P] 
  break goal Q into goals (P -> Q) and P

* assert [P]
  break goal Q into goals P and (P -> Q)

* auto n 
  recursive combo of intros/assumption/apply to depth n
  default 5

* trivial
  weaker version of auto, for proof readibility

* unfold
  selective delta reduction, followed by other reductions

* split (intro rule for conjunction)
  split = intros; apply conj

* left/right (intro rules for disjunction)
  [left|right] = intros; apply [or_introl|or_intror]

* elim [t|H] (apply respective elimination rule)

* exists (intro rule for witness in existential)

* reflexivity (apply refl_equal)

* pattern/revert
  reintroduce an indentifier t into the goal statement
  pattern will construct a lambda function with input t
  revert will construct a universal quantifier (forall)

! rewrite, replace, cutrewrite, symmetry, transitivity

* case [t]
  replace all instances of inductive type t
  with all possible cases for the value of t

* discriminate
  prove a=b -> False for inductive types.
  some automation seems to be involved as well to
  resolve trivial results. 

* injection
  applies the inference on equalities based on the rule
  that constructors of inductive types are injective
  
* change
  replace the goal with an equivalent convertible 
  statement. Good for reframing a goal to allow
  for use of rewrite rules.
  - Ex: Can be used to wrap both sides of a goal
    with a cancellable pair of functions (p. 154)

* generalize
  reintroduce an element from the context into the goal
  statement as an inference.

